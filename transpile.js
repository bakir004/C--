const fs = require("fs");
const nearley = require("nearley");
const grammar = require("./parser.js"); // generated by nearleyc
const { exec } = require("child_process");

const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
const code = fs.readFileSync("example.nigga", "utf-8");

parser.feed(code);

console.log(JSON.stringify(parser.results[0], null, 2))

function transpile(node) {
  switch(node.type) {
    case "fun_definition": 
      return "function " + node.name.value + "(" + node.parameters.map(transpile).join(",")
        + ")\n" + transpile(node.body)
    case "identifier":
      return node.value
    case "code_block":
      return "{" + node.statements.map(transpile).join("\n") + "}"
    case "var_assignment":
      return "let "+transpile(node.var_name) + "=" + transpile(node.value)
    case "binary_operation":
      return transpile(node.left) + transpile(node.operator) + transpile(node.right)
    case "multiply":
      return node.value
    case "number_literal":
      return node.value
    case "return_statement":
      return "return " + transpile(node.value);
    case "var_reference":
      return transpile(node.var_name)
    case "unary_minus":
      return '-' + transpile(node.value)
    case "call_expression": {
      if(node.fun_name.type === 'identifier' && node.fun_name.value === 'print')
        return "console.log(" + node.arguments.map(transpile) + ")"
      return transpile(node.fun_name) + "(" + node.arguments.map(transpile) + ")"
    }
  }
}
const jsCode = parser.results[0].map(transpile).join("\n")
console.log(jsCode)

const fileName = "output.js";
fs.writeFileSync(fileName, jsCode, "utf-8");

exec(`node ${fileName}`, (error, stdout, stderr) => {
  if (error) {
    console.error(`Execution error: ${error.message}`);
    return;
  }
  if (stderr) {
    console.error(`Runtime error:\n${stderr}`);
    return;
  }

  console.log(`Program output:\n${stdout}`);
});
